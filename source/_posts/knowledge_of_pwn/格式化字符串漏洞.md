---
title: 格式化字符串漏洞
date: 2026-01-22 18:36:14
tags:
  - Pwn
---

格式化字符串漏洞 (Format String Vulnerability) 是一种存在于 C/C++ 等语言中的经典漏洞。它源于程序使用了不受信任的用户输入作为格式化函数的参数（如 `printf` 系列函数）。

这种漏洞允许攻击者泄露栈上的数据（信息泄露），甚至向任意内存地址写入数据（代码执行）。

### 1. 核心原理

#### 函数的工作方式
C 语言中的 `printf` 函数定义如下：
`int printf(const char *format, ...);`

它接受一个固定参数 `format`（格式化字符串），后面跟着可变数量的参数。
*   当 `printf` 解析到 `%d`, `%x`, `%s` 等占位符时，它会认为栈（Stack）（或者寄存器）中下一个位置存放着对应的数据，并将其取出打印。

#### 漏洞成因
如果程序员写成了：
```c
// 安全写法
printf("%s", user_input); 

// 不安全写法！！！
printf(user_input); 
```
在不安全写法中，`user_input` 直接变成了格式化字符串。

攻击逻辑：
如果攻击者输入的 `user_input` 包含了 `%x`、`%p` 等占位符，但并没有提供对应的后续参数，`printf` 并不知道参数缺失。它会傻傻地继续从栈上往下读取数据，把栈上的局部变量、返回地址、Canary 等敏感信息当作参数打印出来。

#### 关键的格式控制符
攻击者主要利用以下控制符：
1.  `%x` / `%p`：以十六进制打印栈上的数据 -> 泄露内存（Memory Leak）。
2.  `%s`：将栈上的值视为指针，打印该地址指向的字符串 -> 任意地址读取（Arbitrary Read）。
3.  `%n`：这是最危险的。它不打印任何内容，而是将当前已经成功打印的字符数量，写入到栈上对应的指针指向的内存地址中 -> 任意地址写入（Arbitrary Write）。


### 2. 攻击示例

假设我们有以下漏洞代码 `vuln.c`：

```c
#include <stdio.h>
#include <string.h>

void vulnerable_function() {
    char buffer[100];
    int secret_val = 0x11223344; // 栈上的敏感数据
    
    // 获取用户输入
    printf("Please enter text: ");
    fgets(buffer, sizeof(buffer), stdin);
    
    // 漏洞点：直接打印 buffer，没有用 "%s"
    printf(buffer); 
    
    printf("\nDone.\n");
}

int main() {
    vulnerable_function();
    return 0;
}
```

#### 场景一：泄露栈内存 (Memory Leak)

正常使用：
输入：`Hello`
输出：`Hello`

攻击使用：
攻击者输入：`%x %x %x %x`

发生了什么？
`printf` 看到 4 个 `%x`，于是它去栈上依次抓取 4 个 4字节的数据并打印出来。
输出结果可能如下：
```text
ff9a12b0 11223344 00000001 f7e2ca00
```
看！第二个值 `11223344` 正是代码中的 `secret_val`。攻击者成功读取了函数的局部变量。如果继续添加 `%x`，甚至可以读到 `Canary` 或 `Ret Address`。

#### 场景二：任意地址写入 (利用 `%n`)

这是格式化字符串漏洞能导致 RCE (远程代码执行) 的关键。假设攻击者想修改 `secret_val` 的值。

原理：
`%n` 会把前面打印的字符个数写入变量。

构造 Payload：
假设通过调试，我们发现输入字符串存放的地址在栈上的偏移是第 6 个参数的位置。
我们要把某个内存地址的值改成 `4`。

输入：`AAAA%n`

1.  `printf` 打印 "AAAA"（4个字符）。
2.  遇到 `%n`。
3.  `printf` 取出栈上对应的参数（假设这里恰好是某个变量的地址指针）。
4.  `printf` 将数字 `4` 写入该地址。

高级利用（修改特定地址）：
攻击者通常会在输入的开头放入目标地址（例如 `secret_val` 的地址，或者是 `GOT` 表中 `printf` 的地址），然后利用 `%k$n`（指定第 k 个参数）来精确定位并写入。

例如：`\xef\xbe\xad\xde%100c%6$n`
1.  `\xef\xbe\xad\xde`：目标地址（4字节）。
2.  `%100c`：打印 100 个空白字符。此时总打印字符数 = 4 + 100 = 104。
3.  `%6$n`：找到第 6 个参数（正是开头的那个地址），将数字 `104` 写入该地址。

通过这种方式，攻击者可以将 `printf` 的 GOT 表地址修改为 `system` 函数的地址，下次调用 `printf` 时实际上执行的是 `system("/bin/sh")`。

### 总结

*   漏洞本质：信任了用户的输入作为格式化字符串。
*   后果：
    *   泄露：利用 `%p`, `%s` 查看内存布局、Canary、代码基址。
    *   崩溃：利用 `%s` 访问非法地址导致 Segmentation Fault (DoS)。
    *   篡改：利用 `%n` 修改内存，劫持控制流 (Get Shell)。
*   修复：永远不要使用 `printf(buf)`，始终使用 `printf("%s", buf)`。
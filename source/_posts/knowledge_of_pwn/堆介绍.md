---
title: 堆介绍
date: 2026-01-26 09:51:06
tags:
  - Pwn
---

**堆 (Heap)** 是计算机内存管理中用于**动态内存分配**的一个区域。

与栈（Stack）不同，堆上的内存**不由编译器自动管理**，而是由程序员通过代码显式地申请（`malloc`/`new`）和释放（`free`/`delete`）。如果在高级语言（如 Java, Python）中，则由垃圾回收器（GC）负责回收。

为了让你深入理解堆，我们将从**概念对比、物理结构、逻辑结构（管理机制）**三个层面进行详细剖析。此处主要以 Linux 下最常用的 **glibc ptmalloc** 分配器为例。


### 1. 堆 vs 栈：宏观对比

理解堆的最好方式是将其与栈进行对比：

| 特性 | 栈 (Stack) | 堆 (Heap) |
| :--- | :--- | :--- |
| **分配方式** | **静态/自动**：函数调用时自动压栈。 | **动态/手动**：程序运行时决定分配多少。 |
| **生命周期** | 函数返回时自动释放。 | 直到程序员 `free` 或程序结束才释放。 |
| **生长方向** | **高地址 -> 低地址** | **低地址 -> 高地址** (通常情况) |
| **内存布局** | 连续的线性区域。 | 碎片化的，由链表连接的离散区域。 |
| **管理效率** | 极高（仅需移动 SP 指针）。 | 较低（涉及复杂的算法寻找合适空块）。 |
| **主要用途** | 局部变量、函数参数、返回地址。 | 大的数据结构、对象、文件缓冲区。 |


### 2. 堆的物理结构：Chunk (堆块)

在操作系统眼中，堆只是一大块可读写的内存。但在**分配器（Allocator，如 ptmalloc）**眼中，堆是由无数个 **Chunk** 组成的。

当你调用 `p = malloc(16)` 时，系统并不是只划拨 16 字节给你，而是分配了一个包含**元数据 (Metadata)** 的 Chunk。

#### 64位系统中已分配 Chunk 的结构：
```text
    +---------------------------------------+
    |       prev_size (8 bytes)             |  <-- 如果前一个块空闲，存其大小；否则复用为数据
    +---------------------------------------+
    |       size (8 bytes)        | A|M|P   |  <-- 当前块大小 + 标志位
    +---------------------------------------+  <-- 返回给用户的指针 p 指向这里
    |                                       |
    |          User Data (用户数据)          |
    |                                       |
    +---------------------------------------+
```

#### 64位系统中空闲 (Freed) Chunk 的结构：
```text
    +---------------------------------------+
    |       prev_size (8 bytes)             |
    +---------------------------------------+
    |       size (8 bytes)        | A|M|P   |
    +---------------------------------------+
    |       fd (Forward Pointer)            |  <-- 指向链表中下一个空闲块
    +---------------------------------------+
    |       bk (Backward Pointer)           |  <-- 指向链表中上一个空闲块
    +---------------------------------------+
    |       ... Unused Data ...             |
```

*   **size**: 记录当前 Chunk 的总大小（含 Header）。因为堆块必须 8 或 16 字节对齐，size 的低 3 位通常为 0，被用作**标志位**：
    *   **P (PREV_INUSE)**: **最关键的位**。为 1 表示前一个物理相邻的 Chunk 正在使用；为 0 表示前一个 Chunk 是空闲的（此时 `prev_size` 有效，可以进行合并）。
    *   **M (IS_MMAPPED)**: 表示该内存是通过 `mmap` 系统调用直接分配的。
    *   **A (NON_MAIN_ARENA)**: 表示该 Chunk 属于非主线程的 Arena。


### 3. 堆的逻辑结构：Bins (垃圾分类回收箱)

堆管理器为了快速分配内存，不会把所有空闲的块扔在一个大池子里，而是像垃圾分类一样，根据**大小**将空闲 Chunk 挂在不同的**链表 (Bins)** 上。

当用户 `malloc` 时，分配器会按特定顺序去这些 Bin 里找空块；当用户 `free` 时，Chunk 会被扔进对应的 Bin。

Glibc ptmalloc 主要有以下 5 种管理结构：

#### 1. Tcache (Thread Local Cache) - *现代堆利用的重点*
*   **引入版本**: glibc 2.26+。
*   **特点**: **每个线程独有**，无需加锁，速度极快。
*   **结构**: 单向链表 (LIFO)。
*   **机制**: `malloc` 时优先从这里拿；`free` 时优先放进这里。
*   **安全性**: 早期版本几乎没有安全检查（Double Free 极易触发），是堆利用的重灾区。

#### 2. Fastbin
*   **特点**: 存放**小块**内存（16B ~ 80B 左右）。
*   **结构**: 单向链表 (LIFO)。
*   **特殊性**: 即使被释放了，它的 `P` 标志位依然保持为 1（假装在使用）。这样做是为了**防止它被合并**，以便下次能快速取用。

#### 3. Unsorted Bin
*   **特点**: **中转站**。
*   **结构**: 双向链表。
*   **机制**: 当一个 Chunk 刚被释放（且放不进 Tcache/Fastbin）时，或者大块内存被切割后剩余的部分，都会先扔到这里。
*   **作用**: 给分配器一个“反悔”的机会（也许马上又要用到这块地）。如果下次 `malloc` 没匹配到，这里的块才会被整理到 Small/Large Bin。

#### 4. Small Bin
*   **特点**: 存放中小块内存（< 512B 或 1024B）。
*   **结构**: 双向链表 (FIFO)。
*   **机制**: 每个 Bin 只存放**固定大小**的 Chunk。

#### 5. Large Bin
*   **特点**: 存放**大块**内存。
*   **结构**: 双向链表 + 跳表逻辑 (Skip List)。
*   **机制**: 一个 Bin 存放**一定范围大小**的 Chunk，按大小排序，以便通过“最佳适配 (Best Fit)”算法找到最小的满足要求的块。

#### 6. Top Chunk
*   **概念**: 堆内存最顶端的那一大块未被切分的“处女地”。
*   **作用**: 如果所有的 Bin 里都找不到合适的空闲块，就会切分 Top Chunk。如果 Top Chunk 也不够了，就通过 `sbrk` 或 `mmap` 向操作系统申请更多内存。


### 4. 堆的运作流程 (简化版)

#### 当 `malloc(size)` 发生时：
1.  **查 Tcache**: 对应大小的链表里有空块吗？有就直接给。
2.  **查 Fastbin**: 有就给。
3.  **查 Unsorted Bin**: 遍历这里的块。
    *   如果有大小刚好的，直接给。
    *   如果没有，把这里的块进行分类，放入 Small/Large Bin。
4.  **查 Small/Large Bin**: 找到最合适的块（Best Fit）。
    *   如果块太大，**切割 (Split)**。剩下的部分扔回 Unsorted Bin。
5.  **用 Top Chunk**: 切一块下来。
6.  **最后手段**: 找 OS 扩容。

#### 当 `free(ptr)` 发生时：
1.  **进 Tcache**: 如果 Tcache 没满（默认每个链表7个），直接塞进去。
2.  **进 Fastbin**: 如果块比较小，塞进去。
3.  **合并 (Coalesce)**:
    *   利用 `prev_size` 检查前一个物理块是否空闲。
    *   利用物理相邻地址检查后一个块是否空闲。
    *   如果空闲，把它们从原来的 Bin 摘下来（Unlink），合并成一个大块。
4.  **进 Unsorted Bin**: 合并后的大块扔进去。


### 5. 为什么堆容易出漏洞？

正是因为堆管理的**复杂性**和**元数据与用户数据混储**的特性：

1.  **元数据裸露**: `malloc` 给你的指针 `p` 指向数据区，但 `p-8` 或 `p-16` 就是元数据。一旦发生溢出，攻击者就能修改 `size` 或 `fd/bk` 指针。
2.  **信任机制**: `free` 的时候，分配器主要依赖元数据来判断如何操作。如果元数据被篡改，分配器就会执行错误的操作（如把任意地址标记为堆块并分配给用户）。
3.  **指针残留**: 很多时候 `free(p)` 后，程序员忘了写 `p = NULL`。这导致了 **UAF (Use-After-Free)**，攻击者可以通过这个悬挂指针读写已经被系统回收（甚至重新分配）的内存。

### 总结

*   **堆**是用于动态分配的大片内存区域。
*   它通过 **Chunk**（包含数据头）作为基本单位。
*   它通过 **Bins**（链表数组）来高效管理空闲块。
*   堆利用（Heap Exploitation）的本质，通常是利用溢出或逻辑漏洞破坏 **Chunk 的元数据**，诱导分配器（Malloc/Free）去修改不该修改的内存地址（如 GOT 表、栈变量等）。